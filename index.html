<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello wasm-pack!</title>
</head>

<body>
    <canvas id="vote-map" style="width: 100%; max-width: 512px;"></canvas>
    <script type="module">
        import init, { render, max_candidates } from './pkg/voting_map.js';

        async function main() {
            await init();
            reloadOnChange();

            // Make the canvas square.
            const canvas = document.getElementById('vote-map');
            canvas.style.height = canvas.clientWidth + 'px';

            let isDrawing = false;
            let selected = null;
            // const candidates = [[0.4, 0.87], [0.6, 0.87], [0.07, 0.13], [0.93, 0.13]];
            // const candidates = [[0.12, 0.28], [0.85, 0.7], [0.39, 0.28], [0.97, 0.14]];
            const candidates = [[0.5, 0.87], [0.07, 0.13], [0.93, 0.13]];

            const draw = () => {
                // Low quality but fast preview during dragging, higher quality rendering otherwise.
                const mapSize = selected == null ? 128 : 64;

                // Set the rendered size, as opposed to the size that the element is scaled to. 
                canvas.height = mapSize;
                canvas.width = mapSize;

                const ctx = canvas.getContext('2d');
                try {
                    const candidateCoords = [];
                    for (const [x, y] of candidates) {
                        candidateCoords.push(x);
                        candidateCoords.push(y);
                    }

                    const data = render(mapSize, candidateCoords);
                    const image = new ImageData(Uint8ClampedArray.from(data), mapSize, mapSize);
                    ctx.putImageData(image, 0, 0);
                    for (const [x, y] of candidates) {
                        ctx.beginPath();
                        ctx.arc(x * mapSize, y * mapSize, 5, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                } catch (e) {
                    console.error(e);
                }
            }

            const relativeCoords = ev => {
                const rect = canvas.getBoundingClientRect();
                const x = (ev.clientX - rect.left) / canvas.clientWidth;
                const y = (ev.clientY - rect.top) / canvas.clientHeight;
                return [x, y];
            }

            let lastPos = null;

            const selectCandidate = ev => {
                const [x, y] = relativeCoords(ev);
                lastPos = [x, y];

                let minDist = 1;
                for (const cand of candidates) {
                    const [cx, cy] = cand;
                    const dist = Math.sqrt(Math.pow(cx - x, 2) + Math.pow(cy - y, 2));
                    if (dist < minDist && dist < 0.05) {
                        selected = cand;
                        minDist = dist;
                    }
                }

                if (!selected && candidates.length < max_candidates()) {
                    candidates.push([x, y]);
                    selected = candidates[candidates.length - 1];
                }
            };

            canvas.addEventListener('mousedown', selectCandidate);
            canvas.addEventListener('touchstart', ev => {
                ev.preventDefault();
                selectCandidate(ev.touches[0]);
            });

            const dragEnd = () => {
                if (selected != null) {
                    const [x, y] = lastPos;
                    if (x <= 0 || x >= 1 || y <= 0 || y >= 1) {
                        // Out of bounds, remove the candidate.
                        const i = candidates.indexOf(selected);
                        candidates.splice(i, 1);

                    }
                }
                selected = null;
                requestAnimationFrame(draw);
            };

            document.addEventListener('mouseup', ev => {
                lastPos = relativeCoords(ev);
                dragEnd();
            });
            document.addEventListener('touchend', dragEnd);

            const moveCandidate = ev => {
                const [x, y] = relativeCoords(ev);
                lastPos = [x, y];
                if (!selected || x < 0 || x > 1 || y < 0 || y > 1) return;
                selected[0] = x;
                selected[1] = y;
                requestAnimationFrame(draw);
            }

            canvas.addEventListener('mousemove', moveCandidate);
            canvas.addEventListener('touchmove', (ev) => {
                ev.preventDefault();
                moveCandidate(ev.touches[0]);
            });

            requestAnimationFrame(draw);
        }

        async function reloadOnChange(createdAt = null) {
            const r = await fetch('./pkg/voting_map_bg.wasm', { method: 'HEAD' });
            const lastModified = r.headers.get("Last-Modified");

            if (createdAt != null && createdAt != lastModified) {
                document.location.reload();
            } else {
                setTimeout(() => reloadOnChange(lastModified), 500);
            }
        }

        main();
    </script>
</body>

</html>